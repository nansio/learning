# 正则表达式


## 一、基础概念

### 1. 限定符 Quantifiers

匹配单个字符：
- \? : 0 || 1
- \+ : >= 1
- \* : 0 || n

匹配固定数量字符或数量范围的字符

```
go{2}d
go{2,3}d
go{2,}d
```

匹配多个字符：

```
(na)+
```

### 2. 或运算符 OR Operator

```
(na|an)+
```

### 3. 字符类 Character Class

[123]+:要匹配的字符串只能取自方括号内，

```
[a-z]+
[0-9]+
[^a-zA-z]+
```

元字符 Meta Character

|元字符|含义|
|----|----|
|\d|数字(digit)|
|\w|字符(word)|
|\s|空格(space)|
|\D|非数字|
|\W|非字符|
|\S|非空格|
|.|除换行符以外的所有字符|
|^|字符串开头|
|$|字符串结尾|

## 二、高级概念

### 1. 懒惰匹配和贪婪匹配 Lazy and Greed
在正则表达式中加"?"来开启**懒惰匹配**，开启后，正则会尽可能少的匹配字符。

```
# 非懒惰匹配
<.+>

#懒惰匹配
<.+?>
```
### 2. 分组 Group

通过圆括号()将正则匹配的字符串分组

```
(\d{4})-(\d{7})
```
上述正则第一组匹配四个数字，第二组匹配7个数字

###  3. 非捕获分组 Non-capture Group

非捕获分组：在分组匹配之后，通过`?:`语法将分组过滤，不保存在返回结果中

```js
const str = "2022-08-17";
const reg = /(\d{4})-(?:\d{2})-(\d{2})/;
const result = reg.exec(str)
// result: ['2022-08-17', '2022', '17', ...]
```

### 4. 回溯 Flash Back

```regexp
<([\w]+)>.*<\/\1>
```
`\1`是对第一个分组的引用，来确保第二个分组与第一个分组保持一致

### 5. 断言 Assertion

**断言**有些地方叫做环视(Lookaround)，它只进行子表达式的匹配，不占用字符，匹配到的内容不保存到最终的匹配结果。

(1). **正向先行断言**
表达式： `(?=匹配字符)`

```regexp
喜欢(?=你)
```
匹配“你”前面有喜欢的文字

(2). **反向先行断言**
表达式： `(?!匹配字符)`

```regexp
喜欢(?!你)
```
排除“喜欢”后面有你的文字

(3). **正向后行断言**
表达式： `(?<=匹配字符)`

```regexp
喜欢(?<=我)喜欢
```
匹配“喜欢”前面有“我”的文字


(4). **反向后行断言**
表达式： `(?<!匹配字符)`

```regexp
喜欢(?<!我)喜欢
```
排除“喜欢”前面有“我”的文字

## 三、 JavaScript中的正则方法

### 1. `test()`

